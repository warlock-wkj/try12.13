递归函数,算法: 面试

递归函数: 自己调用自己
核心思想: 把一个大问题,拆成一个一个小问题,逐个解决

递归函数必须有退出的条件,会死掉

斐波那契数列: Fibonacci 黄金分割数列  兔子数列

条件:
1.有一对兔子,一公一母
2.假设兔子不死
3.两个月长大,每个月生一对小兔子

第7个月有几对兔子?

1   1
2   1
3   2  一老一小
4   3  一老两小
5   5  二老三小
6   8  三老五小
7   13 四老九小

7月份多少对兔子

1  1   2  3  5  8  13 21

12

12 * 3: 

5 * 12

递归非常快, 菲波那切数列非常慢,慢在重复计算

优化: 不让他重复计算
	计算过的值,保存起来;没有计算过的,让它继续算

	arr

算法: 步骤,做事件的步骤
算法不一样,导致结果也不一样

有序数组: 查找数组里面是否有一个元素 6

一个个比较的查找: isFindInArr 线性查找
			
			最少         最多                     平均
线性查找     1            n                      n / 2

二分查找     1            log2n (2是底数)   	log2n/ 2

7:   7    3     2倍

100: 100  7     13倍

1000: 1000  10  100倍

10000:              

1   2   3   4   5  6  7


规定: 中间数据偏左 (向下取整)

0-6: 3

1-9: 5

2-8: 5 

1-4: 2


二分法查找: 取得中间的数据,再往两边查找: 用目标数据和中间值比较,如果比中间值小,往左边查,start=原start,end=mid-1;如果比中间值大,往右边查,start=mid+1,end=原end
1   2   3   4   5  6  7
sort(arr,v,start,end)

Maximum call stack size exceeded: 内存溢出

分治法(二分法)

不在乎代码量,实现就行;算法是看性能的

请写出几个常见的排序算法?
冒泡: 从第一个数开始,比较后面的每一个数据,如果第一个数大于后面的数,则调换位置

选择排序: 从当前下标开始,找从该下标+1以后的数的最小值,然后调换位置

归并排序(正宗二分法): 采用二分法,左边一个排序好的数组,右边一个排序好的数组,每次比较左右第一个数,小的,放到一个新的数组

快速排序(二分法): 采用二分法,取出中间数数组,也有左右两边的数组,和中间数组值比较,小的放在左边,大的放到右边,最后连接左中右三个数组
